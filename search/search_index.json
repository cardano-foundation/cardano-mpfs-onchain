{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cardano MPFS Onchain","text":"<p>Aiken validators for Merkle Patricia Forestry on Cardano (Plutus V3).</p> <p>This repository contains the on-chain component of the MPFS project by the Cardano Foundation. The validators were originally developed in <code>on_chain/</code> of that repository.</p> <p>The on-chain component defines a cage pattern: an NFT locked at a script address carries the current MPF root hash as its datum. Modifications are verified on-chain via cryptographic proofs. Time-gated phases prevent race conditions between the oracle and requesters, and a Reject mechanism enables DDoS protection.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Development \u2014 building, dev shell, justfile recipes</li> <li>Architecture Overview \u2014 system diagram, transaction lifecycle, protocol flow</li> <li>Validators \u2014 minting policy and spending validator logic</li> <li>Types &amp; Encodings \u2014 datum, redeemer, and operation structures</li> <li>Proof System \u2014 MPF proof format, verification, and performance</li> <li>Security Properties \u2014 16 categories verified by 80 tests</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Nix with flakes enabled</li> <li>just (optional, for convenience recipes)</li> </ul>"},{"location":"development/#building","title":"Building","text":"<p>Build the Plutus blueprint (<code>plutus.json</code>) in a reproducible Nix sandbox:</p> <pre><code>just build\n# or directly:\nnix build\n</code></pre> <p>The output is a symlink <code>result</code> pointing to the produced <code>plutus.json</code>.</p>"},{"location":"development/#development-shell","title":"Development shell","text":"<p>Drop into a shell with <code>aiken</code> available:</p> <pre><code>just develop\n# or directly:\nnix develop\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>Run the Aiken test suite (requires aiken in PATH or from <code>nix develop</code>):</p> <pre><code>just test\n</code></pre>"},{"location":"development/#justfile-recipes","title":"Justfile recipes","text":"Recipe Description <code>just build</code> Build <code>plutus.json</code> via Nix <code>just develop</code> Enter dev shell with <code>aiken</code> <code>just test</code> Run <code>aiken check</code> tests"},{"location":"development/#how-the-nix-build-works","title":"How the Nix build works","text":"<p>The flake pre-fetches the three Aiken dependencies (stdlib, fuzz, merkle-patricia-forestry) using <code>fetchFromGitHub</code> and populates <code>build/packages/</code> before running <code>aiken build</code>. This avoids network access inside the Nix sandbox.</p>"},{"location":"development/#upstream","title":"Upstream","text":"<p>The validators originate from the cardano-foundation/mpfs repository (<code>on_chain/</code> directory). See the upstream documentation for the full MPFS system including the off-chain TypeScript service.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#system-context","title":"System Context","text":"<p>The on-chain validators are one half of the MPFS system (documentation). They enforce the rules for creating, updating, and destroying MPF token instances on the Cardano blockchain. The off-chain service that builds transactions and manages the trie lives in the <code>off_chain/</code> directory of the upstream repository.</p> <pre><code>graph TD\n    subgraph Blockchain\n        V[\"Cage Validators\"]\n        S1[\"Token X&lt;br/&gt;State UTxO\"]\n        R1[\"Request UTxOs\"]\n    end\n\n    O[\"Oracle&lt;br/&gt;(token owner)\"]\n    A[\"Requester A\"]\n    B[\"Requester B\"]\n    Obs[\"Observer\"]\n\n    O --&gt;|\"Boot / Modify / Reject / End\"| V\n    A --&gt;|\"Submit request\"| R1\n    B --&gt;|\"Submit / Retract request\"| R1\n    R1 --&gt;|\"consumed by Modify or Reject\"| S1\n    Obs -.-&gt;|\"read chain history\"| Blockchain</code></pre> <p>The oracle (token owner) controls the MPF token: it boots the token, applies pending requests via <code>Modify</code>, rejects expired or dishonest requests via <code>Reject</code>, and can destroy it with <code>End</code>. Requesters submit modification requests as UTxOs at the script address and can retract them during Phase 2. Observers read the MPF state from the blockchain history \u2014 no on-chain interaction is needed.</p>"},{"location":"architecture/overview/#transaction-lifecycle","title":"Transaction Lifecycle","text":"<p>The token and requests have separate lifecycles that intersect when the oracle processes a <code>Modify</code> transaction.</p> <pre><code>stateDiagram-v2\n    state \"Token Lifecycle\" as TL {\n        [*] --&gt; Active: Boot (Mint)\n        Active --&gt; Active: Modify / Reject\n        Active --&gt; Active: Migrate (new validator)\n        Active --&gt; [*]: End (Burn)\n    }\n\n    state \"Request Lifecycle\" as RL {\n        [*] --&gt; Phase1: Submit (pay to script)\n        Phase1 --&gt; Consumed: Contribute + Modify\n        Phase1 --&gt; Phase2: process_time elapsed\n        Phase2 --&gt; [*]: Retract\n        Phase2 --&gt; Phase3: retract_time elapsed\n        Phase3 --&gt; Rejected: Reject (refund minus fee)\n    }</code></pre>"},{"location":"architecture/overview/#time-gated-phases","title":"Time-Gated Phases","text":"<p>Each request passes through three exclusive time phases, enforced on-chain via <code>tx.validity_range</code>. The phase boundaries are determined by the request's <code>submitted_at</code> timestamp and the State datum's <code>process_time</code> and <code>retract_time</code> fields (set at mint time and enforced immutable across Modify/Reject operations).</p> <pre><code>gantt\n    title Request Time Phases\n    dateFormat X\n    axisFormat %s\n\n    section Phases\n    Phase 1 - Oracle Modify   :active, p1, 0, 10\n    Phase 2 - Requester Retract :crit, p2, 10, 20\n    Phase 3 - Oracle Reject    :done, p3, 20, 30</code></pre> Phase Window Allowed Operations Actor Phase 1 <code>[submitted_at, submitted_at + process_time)</code> Modify, Contribute Oracle Phase 2 <code>[submitted_at + process_time, submitted_at + process_time + retract_time)</code> Retract Requester Phase 3 <code>[submitted_at + process_time + retract_time, ...)</code> Reject Oracle <p>A request with a dishonest <code>submitted_at</code> (in the future) is immediately rejectable by the oracle, regardless of phase.</p> Transaction Action Validator Phase Boot Mint a new MPF token with empty root Minting policy \u2014 Submit Lock ADA at script with a modification request \u2014 (pay to script, no validator) \u2014 Modify Oracle applies pending requests, updates MPF root Spending validator (Modify on state + Contribute on each request) 1 Retract Request owner cancels a pending request, reclaims ADA Spending validator (Retract) 2 Reject Oracle discards expired/dishonest requests, refunds ADA minus fee Spending validator (Reject on state + Contribute on each request) 3 Migrate Move token to a new validator version Minting policy (Burning old + Migrating new) + Spending validator (End) \u2014 End Burn the MPF token, destroy the instance Minting policy (Burning) + Spending validator (End) \u2014"},{"location":"architecture/overview/#protocol-flow","title":"Protocol Flow","text":"<pre><code>sequenceDiagram\n    participant O as Oracle\n    participant B as Blockchain\n    participant A as Alice (requester)\n    participant C as Bob (requester)\n\n    O-&gt;&gt;B: Boot Token X (Mint)\n    Note over B: Token X created with empty root\n\n    A-&gt;&gt;B: Submit Request: Insert(\"keyA\", \"valA\")\n    C-&gt;&gt;B: Submit Request: Insert(\"keyB\", \"valB\")\n    Note over B: Two Request UTxOs at script address\n\n    rect rgb(40, 80, 40)\n        Note over O,B: Phase 1 \u2014 Oracle processes requests\n        O-&gt;&gt;B: Modify Token X (consumes both requests)\n        Note over B: Root updated: empty \u2192 root(keyA, keyB)\n    end\n\n    A-&gt;&gt;B: Submit Request: Delete(\"keyB\", \"valB\")\n    rect rgb(40, 80, 40)\n        Note over O,B: Phase 1\n        O-&gt;&gt;B: Modify Token X\n        Note over B: Root updated: root(keyA, keyB) \u2192 root(keyA)\n    end\n\n    C-&gt;&gt;B: Submit Request: Delete(\"keyA\", \"valA\")\n    rect rgb(80, 80, 40)\n        Note over C,B: Phase 2 \u2014 Requester retracts\n        C-&gt;&gt;B: Retract own request\n        Note over B: Request UTxO reclaimed, root unchanged\n    end\n\n    A-&gt;&gt;B: Submit Request: Insert(\"spam\", \"data\")\n    rect rgb(80, 40, 40)\n        Note over O,B: Phase 3 \u2014 Oracle rejects expired request\n        O-&gt;&gt;B: Reject (refund ADA minus fee, root unchanged)\n    end\n\n    O-&gt;&gt;B: End Token X (Burn)\n    Note over B: Token destroyed</code></pre>"},{"location":"architecture/overview/#security-properties","title":"Security Properties","text":"<p>The validators enforce invariants across 16 categories, each verified by the inline test suite (80 tests):</p> <ol> <li>Ownership \u2014 only the oracle (token owner) can modify, reject, or destroy a token.</li> <li>Integrity \u2014 every MPF modification carries a cryptographic proof    verified on-chain; the output root must match the proof computation.</li> <li>Uniqueness \u2014 token IDs are derived from spent UTxOs, guaranteed    unique by the ledger.</li> <li>Confinement \u2014 the token must remain at the script address after    every operation.</li> <li>Retractability \u2014 request owners can reclaim their locked ADA during Phase 2.</li> <li>Request binding \u2014 a request's target token is validated on-chain    before it can be consumed.</li> <li>Type safety \u2014 each redeemer/datum combination is enforced; mismatches    are rejected.</li> <li>Time-gated phases \u2014 each request passes through three exclusive phases    (oracle Modify, requester Retract, oracle Reject), preventing race conditions.</li> <li>DDoS protection \u2014 expired or dishonest requests can be rejected by the    oracle, who keeps the fee and refunds the rest.</li> <li>Fee enforcement \u2014 oracle fees are validated on-chain; requesters are     refunded correctly.</li> </ol> <p>See Security Properties for the complete list with test cross-references.</p>"},{"location":"architecture/overview/#aiken-dependencies","title":"Aiken Dependencies","text":"Dependency Version Purpose aiken-lang/stdlib v2.2.0 Standard library (assets, transactions, addresses) aiken-lang/merkle-patricia-forestry v2.0.0 MPF trie operations and proof verification aiken-lang/fuzz v2.1.1 Property-based testing (used in test suite only)"},{"location":"architecture/proofs/","title":"Proof System","text":"<p>The on-chain validators verify Merkle Patricia Forestry (MPF) proofs to ensure that every trie modification is cryptographically valid.</p>"},{"location":"architecture/proofs/#mpf-structure","title":"MPF Structure","text":"<p>MPF is a radix-16 (hexadecimal) trie. Each node has up to 16 children (one per hex digit). Paths are compressed: consecutive nodes with a single child are collapsed into a single edge with a skip value.</p> <pre><code>graph TD\n    ROOT[\"Root&lt;br/&gt;hash: 4acd78...\"]\n    B1[\"Branch&lt;br/&gt;prefix: 0x3\"]\n    B2[\"Branch&lt;br/&gt;prefix: 0xa\"]\n    L1[\"Leaf&lt;br/&gt;apple \u2192 hash(value)\"]\n    L2[\"Leaf&lt;br/&gt;banana \u2192 hash(value)\"]\n    L3[\"Leaf&lt;br/&gt;cherry \u2192 hash(value)\"]\n\n    ROOT --&gt; B1\n    ROOT --&gt; B2\n    B1 --&gt; L1\n    B1 --&gt; L2\n    B2 --&gt; L3</code></pre>"},{"location":"architecture/proofs/#core-type","title":"Core Type","text":"<pre><code>type MerklePatriciaForestry  -- opaque, wraps a 32-byte root hash\n</code></pre> <p>Constructed via:</p> <ul> <li><code>from_root(root: ByteArray)</code> \u2014 wrap an existing root hash</li> <li><code>empty</code> \u2014 the empty trie (well-known null hash)</li> </ul>"},{"location":"architecture/proofs/#proof-format","title":"Proof Format","text":"<p>A proof is a path from the root to the target element:</p> <pre><code>type Proof = List&lt;ProofStep&gt;\n\ntype ProofStep {\n    Branch { skip: Int, neighbors: ByteArray }\n    Fork { skip: Int, neighbor: Neighbor }\n    Leaf { skip: Int, key: ByteArray, value: ByteArray }\n}\n\ntype Neighbor {\n    nibble: Int\n    prefix: ByteArray\n    root: ByteArray\n}\n</code></pre> Step Description <code>Branch</code> A node with multiple children. <code>skip</code> is the common prefix length. <code>neighbors</code> is a packed byte array of sibling hashes (sparse 16-element array) <code>Fork</code> A node where the path diverges. <code>neighbor</code> describes the other branch <code>Leaf</code> A terminal node. <code>key</code> is the remaining suffix, <code>value</code> is the stored value"},{"location":"architecture/proofs/#public-api","title":"Public API","text":"<p>The MPF library exposes three mutation functions used by the spending validator:</p> <pre><code>fn insert(self, key, value, proof) -&gt; MerklePatriciaForestry\nfn delete(self, key, value, proof) -&gt; MerklePatriciaForestry\nfn update(self, key, proof, old_value, new_value) -&gt; MerklePatriciaForestry\n</code></pre> <p>Each takes the current <code>MerklePatriciaForestry</code> (root), verifies the proof against it, and returns a new root. If the proof is invalid the function fails, aborting the transaction.</p> <p>Internally the library uses two helper functions (<code>including</code> and <code>excluding</code>) that compute what the root hash would be if a key-value pair is present or absent. These are not exported but underpin the public API.</p>"},{"location":"architecture/proofs/#on-chain-operations","title":"On-Chain Operations","text":"<p>The spending validator calls the MPF functions for each request operation:</p>"},{"location":"architecture/proofs/#insert","title":"Insert","text":"<p>Verifies the key is absent (via <code>excluding</code>), then computes the new root with the key present (via <code>including</code>).</p> <pre><code>new_root = mpf.insert(old_root, key, new_value, proof)\n</code></pre>"},{"location":"architecture/proofs/#delete","title":"Delete","text":"<p>Verifies the key is present with the expected value (via <code>including</code>), then computes the new root with the key absent (via <code>excluding</code>).</p> <pre><code>new_root = mpf.delete(old_root, key, old_value, proof)\n</code></pre>"},{"location":"architecture/proofs/#update","title":"Update","text":"<p>Verifies the key is present with the old value, then computes the new root with the new value. Equivalent to a delete + insert but with one fewer membership check.</p> <pre><code>new_root = mpf.update(old_root, key, proof, old_value, new_value)\n</code></pre>"},{"location":"architecture/proofs/#proof-folding","title":"Proof Folding","text":"<p>When multiple requests are processed in a single <code>Modify</code> transaction, proofs are folded left-to-right:</p> <pre><code>graph LR\n    R0[\"root\u2080&lt;br/&gt;(current)\"]\n    P1[\"proof\u2081 + req\u2081\"]\n    R1[\"root\u2081\"]\n    P2[\"proof\u2082 + req\u2082\"]\n    R2[\"root\u2082\"]\n    PN[\"proof_n + req_n\"]\n    RN[\"root_n&lt;br/&gt;(output datum)\"]\n\n    R0 --&gt; P1 --&gt; R1 --&gt; P2 --&gt; R2\n    R2 -.-&gt;|...| PN --&gt; RN</code></pre> <p>Each proof is relative to the intermediate root produced by the previous step. The final root must match the output datum.</p>"},{"location":"architecture/proofs/#hashing","title":"Hashing","text":"<p>MPF uses Blake2b-256 internally for all digests (key hashing, value hashing, node hashing). See the library source for implementation details.</p> <p>Proof size grows logarithmically with the number of elements in the trie, making MPF practical even for very large datasets.</p>"},{"location":"architecture/properties/","title":"Security Properties","text":"<p>This page documents the on-chain security properties of the MPF Cage validators. Each property is stated as an invariant and cross-referenced with the test(s) that verify it.</p> <p>The properties are derived from the upstream MPFS specification (architecture, on-chain code docs) and verified by the inline test suite in <code>cage.ak</code> and <code>lib.ak</code>. Run <code>aiken check</code> (or <code>just test</code>) to check all 80 tests.</p>"},{"location":"architecture/properties/#roles","title":"Roles","text":"<p>The upstream MPFS documentation defines three roles:</p> <ul> <li>Oracle (token owner): controls which facts are added or removed   from an MPF token. Maps to the <code>State.owner</code> field.</li> <li>Requester: proposes fact changes via <code>RequestDatum</code> UTxOs. Maps   to <code>Request.requestOwner</code>.</li> <li>Observer: reads the MPF state from the blockchain. No on-chain   role; all knowledge is reconstructable from the chain history.</li> </ul> <p>The on-chain validators enforce the boundaries between these roles.</p>"},{"location":"architecture/properties/#on-chain-vs-off-chain-guarantees","title":"On-chain vs Off-chain Guarantees","text":"<p>The validators enforce what must hold on-chain. Some guarantees depend on off-chain behaviour:</p> Guarantee Enforced by Token identity is unique On-chain (UTxO consumption) Only the oracle can update the MPF root On-chain (signature check) Every modification carries a valid Merkle proof On-chain (proof verification) Output root matches proof computation On-chain (fold + compare) Token stays at the script address On-chain (address check) Requesters can reclaim locked ADA in Phase 2 On-chain (Retract + phase check) Expired requests are cleaned up On-chain (Reject + phase check) Oracle fees are enforced On-chain (fee == max_fee check) Refunds are paid correctly On-chain (verifyRefunds) Time phases are exclusive On-chain (validity_range checks) The oracle honestly processes matching requests Off-chain (oracle behaviour) Proofs are computed against the correct trie state Off-chain (proof generation) All knowledge is reconstructable from history Blockchain (ledger property)"},{"location":"architecture/properties/#1-token-uniqueness","title":"1. Token Uniqueness","text":"<p>Upstream: \"The new token-id is unique\"</p> <p>Invariant: Two distinct <code>OutputReference</code> values always produce different token asset names.</p> <p>The asset name is <code>SHA2-256(tx_id ++ output_index)</code>. Since an <code>OutputReference</code> can only be consumed once, the minting policy guarantees that no two tokens share the same identity.</p> Property Test File Same reference yields same hash (deterministic) <code>assetName_deterministic</code> <code>lib.ak</code> Different <code>tx_id</code> yields different hash <code>assetName_different_txid</code> <code>lib.ak</code> Different <code>output_index</code> yields different hash <code>assetName_different_index</code> <code>lib.ak</code> Determinism holds for arbitrary references <code>prop_assetName_deterministic</code> <code>lib.ak</code>"},{"location":"architecture/properties/#2-minting-integrity","title":"2. Minting Integrity","text":"<p>Upstream: \"The hash in the token is null\" (at boot)</p> <p>Invariant: A token can only be minted when all of the following hold simultaneously:</p> <ol> <li>The <code>OutputReference</code> is consumed in the transaction.</li> <li>Exactly one token is minted (quantity = 1).</li> <li>The output goes to the validator's own script address.</li> <li>The output carries a <code>StateDatum</code> with <code>root = root(empty)</code>.</li> </ol> <p>Violating any single condition causes the minting policy to reject the transaction.</p> Property Test Violated condition Happy path (all conditions met) <code>canMint</code> -- Reference not consumed <code>mint_missing_input</code> (1) Quantity = 2 <code>mint_quantity_two</code> (2) Output to wallet address <code>mint_to_wallet</code> (3) Output to different script <code>mint_to_wrong_script</code> (3) Non-empty initial root <code>mint_nonempty_root</code> (4) Datum is <code>RequestDatum</code> <code>mint_request_datum</code> (4) Output has <code>NoDatum</code> <code>mint_no_datum</code> (4) Roundtrip: any valid reference produces a valid mint <code>prop_mint_roundtrip</code> --"},{"location":"architecture/properties/#3-ownership-authorization","title":"3. Ownership &amp; Authorization","text":"<p>Upstream: \"MPF tokens can be modified only by their owner\"</p> <p>Invariant: Only the holder of the correct verification key can perform privileged operations.</p> <ul> <li>Modify / Reject / End (oracle operations): require the   <code>State.owner</code> signature.</li> <li>Retract (requester operation): requires the   <code>Request.requestOwner</code> signature.</li> <li>Contribute: permissionless \u2014 anyone can link a request to a   state UTxO.</li> </ul> Property Test Operation Oracle signs Modify <code>canCage</code> Modify Missing oracle signature blocks Modify <code>modify_missing_signature</code> Modify Missing oracle signature blocks End <code>end_missing_signature</code> End Missing oracle signature blocks Reject <code>reject_missing_signature</code> Reject Requester signs Retract <code>retract_happy</code> Retract Wrong signer blocks Retract <code>retract_wrong_signer</code> Retract Random signer != requester fails Retract <code>prop_retract_requires_owner</code> Retract Random signer != oracle fails Modify <code>prop_modify_requires_owner</code> Modify"},{"location":"architecture/properties/#4-token-confinement","title":"4. Token Confinement","text":"<p>Invariant: The caged token must remain at the same script address after a <code>Modify</code> or <code>Reject</code> operation. The output's payment credential must equal the input's payment credential.</p> <p>This prevents the oracle from extracting the token to a wallet or redirecting it to a different script during an update.</p> Property Test Output to different script address is rejected <code>modify_wrong_address</code> Output to same address succeeds <code>canCage</code>, <code>modify_owner_transfer</code>"},{"location":"architecture/properties/#5-ownership-transfer","title":"5. Ownership Transfer","text":"<p>Invariant: The <code>owner</code> field in the output datum is not checked against the input datum during <code>Modify</code>. The current oracle can transfer ownership to a new key by changing the <code>owner</code> field.</p> <p>This is intentional: it enables oracle rotation and delegation without burning and re-minting.</p> Property Test Owner changes from <code>\"owner\"</code> to <code>\"new-owner\"</code> <code>modify_owner_transfer</code> Existing happy path demonstrates transfer <code>canCage</code>"},{"location":"architecture/properties/#6-state-integrity-mpf-root","title":"6. State Integrity (MPF Root)","text":"<p>Upstream: \"All modifications to an MPF root have to appear on-chain\" and \"All modifications must be consumed under a smart contract validation\"</p> <p>Invariant: The output root must exactly match the result of folding all matching request operations over the input root using the provided Merkle proofs. A wrong claimed root is rejected.</p> <p>This is the core cryptographic guarantee: every state transition is provably correct.</p> Property Test Correct root after one Insert <code>canCage</code> Wrong root in output datum <code>modify_wrong_root</code> No requests: root must stay unchanged <code>modify_no_requests</code> Requests for other tokens are skipped <code>modify_skip_other_token</code>"},{"location":"architecture/properties/#7-proof-consumption","title":"7. Proof Consumption","text":"<p>Invariant: Exactly one Merkle proof is consumed per matching request input. Too few proofs causes failure (<code>uncons</code> on empty list). Extra proofs are silently ignored.</p> Property Test One proof per request (happy path) <code>canCage</code> Zero proofs for one request <code>modify_too_few_proofs</code> Two proofs for one request (extra ignored) <code>modify_extra_proofs</code> <p>Note</p> <p>The validator does not reject extra proofs. This is a design choice: it simplifies transaction building when the exact number of matching requests is uncertain at construction time.</p>"},{"location":"architecture/properties/#8-request-binding","title":"8. Request Binding","text":"<p>Upstream: \"All consumed requests reference the token being updated\"</p> <p>Invariant: A <code>Contribute</code> transaction validates that the request's <code>requestToken</code> matches the actual token at the referenced State UTxO. Requests targeting a different token are rejected.</p> <p>This prevents a request intended for token A from being applied to token B.</p> Property Test Matching token succeeds <code>canCage</code> Mismatched token <code>contribute_wrong_token</code> Referenced UTxO not in inputs <code>contribute_missing_ref</code>"},{"location":"architecture/properties/#9-datum-redeemer-type-safety","title":"9. Datum-Redeemer Type Safety","text":"<p>Invariant: Each redeemer expects a specific datum constructor. Using the wrong combination causes the <code>expect</code> pattern match to fail, rejecting the transaction.</p> <p>This enforces a clean separation between State UTxOs (oracle operations) and Request UTxOs (requester operations).</p> Redeemer Required datum Wrong datum test <code>Retract</code> <code>RequestDatum</code> <code>retract_on_state_datum</code> <code>Contribute</code> <code>RequestDatum</code> <code>contribute_on_state_datum</code> <code>Modify</code> <code>StateDatum</code> <code>modify_on_request_datum</code> <code>End</code> <code>StateDatum</code> <code>end_on_request_datum</code>"},{"location":"architecture/properties/#10-datum-presence","title":"10. Datum Presence","text":"<p>Invariant: The spending validator requires <code>Some(datum)</code>. A UTxO with no datum (e.g. accidentally sent ADA to the script address) cannot be spent through any redeemer.</p> Property Test <code>None</code> datum rejected <code>spend_no_datum</code>"},{"location":"architecture/properties/#11-end-burn-integrity","title":"11. End / Burn Integrity","text":"<p>Invariant: The <code>End</code> redeemer verifies that the mint field contains exactly the same token being burned. Burning a different token while keeping the caged one is rejected.</p> Property Test Correct token burned <code>end_happy</code> Different token in mint field <code>end_wrong_token_in_mint</code> End with unrelated extra minting policy <code>end_with_extra_mint_policy</code>"},{"location":"architecture/properties/#12-token-extraction","title":"12. Token Extraction","text":"<p>Invariant: <code>tokenFromValue</code> returns <code>Some(TokenId)</code> only when the value contains exactly one non-ADA policy with exactly one asset name. All other shapes return <code>None</code>.</p> <p>This is a safety function used throughout the validators to identify the caged NFT. If a UTxO somehow contains multiple tokens, extraction fails and the validator rejects.</p> Shape Test Result ADA + 1 NFT <code>tokenFromValue_single_nft</code> <code>Some(TokenId)</code> ADA only <code>tokenFromValue_ada_only</code> <code>None</code> 2 non-ADA policies <code>tokenFromValue_multi_policy</code> <code>None</code> 1 policy, 2 asset names <code>tokenFromValue_multi_asset</code> <code>None</code> Roundtrip via <code>valueFromToken</code> <code>tokenFromValue_roundtrip</code> <code>Some(TokenId)</code>"},{"location":"architecture/properties/#13-time-gated-phases","title":"13. Time-Gated Phases","text":"<p>Invariant: Each request passes through three exclusive time phases. The validator enforces phase boundaries using <code>tx.validity_range</code> and the State datum's <code>process_time</code> / <code>retract_time</code> fields (set at mint time, enforced immutable). No operation can execute outside its designated phase.</p> <pre><code>submitted_at          + process_time       + process_time + retract_time\n    |                        |                        |\n    |   Phase 1: Oracle      |   Phase 2: Requester   |   Phase 3: Oracle\n    |   Modify only          |   Retract only         |   Reject only\n</code></pre> <p>This eliminates the race condition where a requester retracts while the oracle is building a Modify transaction.</p> Property Test Expected Retract blocked in Phase 1 <code>retract_in_phase1</code> fail Retract allowed in Phase 2 <code>retract_happy</code> pass Retract blocked in Phase 3 <code>retract_in_phase3</code> fail Contribute blocked in Phase 2 <code>contribute_in_phase2</code> fail Contribute allowed in Phase 3 (for Reject) <code>contribute_in_phase3</code> pass Modify blocked in Phase 2 <code>modify_in_phase2</code> fail"},{"location":"architecture/properties/#14-reject-ddos-protection","title":"14. Reject (DDoS Protection)","text":"<p>Invariant: The oracle can discard requests that are past their retract window (Phase 3) or have a dishonest <code>submitted_at</code> timestamp. The oracle keeps the fee and refunds the remaining lovelace. The MPF root must not change during a Reject.</p> <p>This prevents DDoS attacks where requesters spam requests and retract them before the oracle can process them.</p> Property Test Expected Reject in Phase 3 (happy path) <code>reject_happy</code> pass Reject blocked in Phase 1 <code>reject_in_phase1</code> fail Reject blocked in Phase 2 <code>reject_in_phase2</code> fail Reject with future <code>submitted_at</code> (dishonest) <code>reject_future_submitted_at</code> pass Reject without owner signature <code>reject_missing_signature</code> fail Reject must not change root <code>reject_root_changes</code> fail Reject with insufficient refund <code>reject_wrong_refund</code> fail"},{"location":"architecture/properties/#15-fee-enforcement","title":"15. Fee Enforcement","text":"<p>Invariant: When the oracle processes requests via <code>Modify</code>, each request's <code>fee</code> must equal <code>state.max_fee</code>. The oracle receives the fee and the requester is refunded <code>lovelace - fee</code>. Refunds are verified on-chain: correct amount, correct address.</p> Property Test Expected Modify with fee and correct refund <code>modify_with_refund</code> pass Modify with missing refund output <code>modify_missing_refund</code> fail Modify with insufficient refund <code>modify_insufficient_refund</code> fail Modify with wrong refund address <code>modify_wrong_refund_address</code> fail Modify with zero fee (no refund deduction) <code>modify_zero_fee</code> pass Request fee != state max_fee <code>modify_fee_mismatch</code> fail"},{"location":"architecture/properties/#16-migration","title":"16. Migration","text":"<p>Invariant: A token can be migrated from an old validator to a new one by atomically burning the old token and minting a new one. The token identity (asset name) and MPF root are preserved. The old token must be burned (-1) in the same transaction.</p> Property Test Expected Migration happy path (burn old, mint new) <code>canMigrate</code> pass Migration without burning old token <code>migrate_no_burn</code> fail Migration to wallet instead of script <code>migrate_to_wallet</code> fail Migration with wrong old policy ID <code>migrate_wrong_old_policy</code> fail"},{"location":"architecture/properties/#summary","title":"Summary","text":"# Category Tests 1 Token uniqueness 4 2 Minting integrity 9 3 Ownership &amp; authorization 8 4 Token confinement 2 5 Ownership transfer 2 6 State integrity (MPF root) 4 7 Proof consumption 3 8 Request binding 3 9 Datum-redeemer type safety 4 10 Datum presence 1 11 End / burn integrity 3 12 Token extraction 5 13 Time-gated phases 6 14 Reject (DDoS protection) 7 15 Fee enforcement 6 16 Migration 4 Total 80"},{"location":"architecture/types/","title":"Types &amp; Encodings","text":"<p>All on-chain data structures are defined in <code>types.ak</code> and compiled to Plutus V3 data encodings.</p>"},{"location":"architecture/types/#token-identity","title":"Token Identity","text":"<pre><code>type TokenId {\n    assetName: AssetName\n}\n</code></pre> <p><code>TokenId</code> wraps only the <code>AssetName</code>. The <code>PolicyId</code> is always the cage script's own hash (since the minting policy and spending validator share the same script) and is passed separately where needed.</p> <p>The <code>AssetName</code> is derived from a consumed UTxO reference via SHA2-256, guaranteeing global uniqueness.</p>"},{"location":"architecture/types/#datum","title":"Datum","text":"<p>Every UTxO at the script address carries a <code>CageDatum</code>:</p> <pre><code>type CageDatum {\n    RequestDatum(Request)\n    StateDatum(State)\n}\n</code></pre>"},{"location":"architecture/types/#state","title":"State","text":"<p>Attached to the UTxO that holds the MPF token.</p> <pre><code>type State {\n    owner: VerificationKeyHash\n    root: ByteArray      -- 32-byte MPF root hash\n    max_fee: Int         -- max lovelace fee per request\n    process_time: Int    -- Phase 1 duration (ms)\n    retract_time: Int    -- Phase 2 duration (ms)\n}\n</code></pre> Field Encoding Description <code>owner</code> 28 bytes Ed25519 public key hash of the token owner <code>root</code> 32 bytes Current MPF root (Blake2b-256). Empty trie has a well-known null hash <code>max_fee</code> integer Maximum fee (in lovelace) the oracle charges per request. Requesters must agree to this fee <code>process_time</code> integer Duration (ms) of Phase 1 \u2014 oracle-exclusive processing window. Set at mint time; enforced immutable across Modify/Reject <code>retract_time</code> integer Duration (ms) of Phase 2 \u2014 requester-exclusive retract window. Set at mint time; enforced immutable across Modify/Reject"},{"location":"architecture/types/#request","title":"Request","text":"<p>Attached to UTxOs representing pending modification requests.</p> <pre><code>type Request {\n    requestToken: TokenId\n    requestOwner: VerificationKeyHash\n    requestKey: ByteArray\n    requestValue: Operation\n    fee: Int\n    submitted_at: Int\n}\n</code></pre> Field Encoding Description <code>requestToken</code> <code>TokenId</code> Target MPF token (asset name only; policy ID is implicit) <code>requestOwner</code> 28 bytes Who can retract this request <code>requestKey</code> variable Key in the MPF trie <code>requestValue</code> <code>Operation</code> What to do with this key <code>fee</code> integer Fee (in lovelace) the requester agrees to pay. Must match <code>state.max_fee</code> at Modify time <code>submitted_at</code> integer POSIXTime (ms) when the request was submitted. Determines which time phase the request is in"},{"location":"architecture/types/#operations","title":"Operations","text":"<pre><code>type Operation {\n    Insert(ByteArray)               -- new_value\n    Delete(ByteArray)               -- old_value\n    Update(ByteArray, ByteArray)    -- old_value, new_value\n}\n</code></pre> Constructor Index Fields Description <code>Insert</code> 0 <code>new_value</code> Insert a new key-value pair (key must not exist) <code>Delete</code> 1 <code>old_value</code> Remove an existing key (must exist with this value) <code>Update</code> 2 <code>old_value, new_value</code> Change the value of an existing key"},{"location":"architecture/types/#redeemers","title":"Redeemers","text":""},{"location":"architecture/types/#minting-redeemer","title":"Minting Redeemer","text":"<pre><code>type Mint {\n    asset: OutputReference\n}\n\ntype Migration {\n    oldPolicy: PolicyId\n    tokenId: TokenId\n}\n\ntype MintRedeemer {\n    Minting(Mint)\n    Migrating(Migration)\n    Burning\n}\n</code></pre> Constructor Index Fields Description <code>Minting</code> 0 <code>Mint { asset: OutputReference }</code> Boot a new token. <code>asset</code> identifies which UTxO to consume for unique naming <code>Migrating</code> 1 <code>Migration { oldPolicy, tokenId }</code> Migrate a token from an old validator. The old token must be burned atomically <code>Burning</code> 2 \u2014 Burn the token (paired with <code>End</code> on the spending side)"},{"location":"architecture/types/#spending-redeemer","title":"Spending Redeemer","text":"<pre><code>type UpdateRedeemer {\n    End\n    Contribute(OutputReference)\n    Modify(List&lt;Proof&gt;)\n    Retract(OutputReference)\n    Reject\n}\n</code></pre> Constructor Index Fields Description <code>End</code> 0 \u2014 Destroy the MPF instance <code>Contribute</code> 1 <code>OutputReference</code> Spend a request during update or reject; points to the state UTxO <code>Modify</code> 2 <code>List&lt;Proof&gt;</code> Update the MPF root; one proof per request. Phase 1 only <code>Retract</code> 3 <code>OutputReference</code> Cancel a request and reclaim ADA. Points to the State UTxO (included as reference input). Phase 2 only <code>Reject</code> 4 \u2014 Discard expired/dishonest requests, refund ADA minus fee. Phase 3 or dishonest <code>submitted_at</code>"},{"location":"architecture/types/#plutus-data-encoding","title":"Plutus Data Encoding","text":"<p>All types compile to standard Plutus V3 <code>Data</code> constructors. The constructor indices match the order listed above (0-indexed).</p> <p>Example \u2014 StateDatum on-chain encoding:</p> <pre><code>Constr(1,           -- CageDatum.StateDatum\n  [ Constr(0,       -- State\n      [ Bytes(owner_pkh)\n      , Bytes(root_hash)\n      , Int(max_fee)\n      , Int(process_time)\n      , Int(retract_time)\n      ])\n  ])\n</code></pre> <p>Example \u2014 RequestDatum with Insert:</p> <pre><code>Constr(0,           -- CageDatum.RequestDatum\n  [ Constr(0,       -- Request\n      [ Constr(0, [Bytes(asset_name)])  -- TokenId\n      , Bytes(owner_pkh)\n      , Bytes(key)\n      , Constr(0, [Bytes(new_value)])   -- Insert\n      , Int(fee)\n      , Int(submitted_at)\n      ])\n  ])\n</code></pre>"},{"location":"architecture/validators/","title":"Validators","text":"<p>The on-chain logic lives in a single script (<code>cage.ak</code>) that implements both a minting policy and a spending validator. Helper functions are in <code>lib.ak</code>.</p>"},{"location":"architecture/validators/#validator-parameters","title":"Validator Parameters","text":"<p>The cage validator is parameterized by a single immutable value, set at deployment time:</p> <pre><code>validator mpfCage(_version: Int) {\n</code></pre> Parameter Type Description <code>_version</code> <code>Int</code> Version tag (enables migration between validator versions) <p>Different parameter values produce different script hashes and addresses. The parameter is baked into the compiled script, so it cannot be changed after deployment.</p> <p>Time parameters in datum</p> <p><code>process_time</code> and <code>retract_time</code> are stored in the <code>State</code> datum rather than as validator parameters. This ensures all oracle configurations share a single script hash and address, which is critical for the off-chain indexer. See Types &amp; Encodings for details.</p>"},{"location":"architecture/validators/#minting-policy-mpfcagemint","title":"Minting Policy (<code>mpfCage.mint</code>)","text":"<p>Controls creation, migration, and destruction of MPF tokens.</p>"},{"location":"architecture/validators/#boot-minting","title":"Boot (Minting)","text":"<p>Creates a new MPF token instance.</p> <p>Validation rules:</p> <ol> <li>Asset name is the SHA2-256 hash of a consumed UTxO reference    (ensures global uniqueness).</li> <li>Exactly one token is minted.</li> <li>The token is sent to the script address.</li> <li>The output datum is a <code>StateDatum</code> with an empty MPF root    (<code>root(empty)</code>).</li> <li>The owner field is unrestricted (any <code>VerificationKeyHash</code>).</li> </ol> <pre><code>graph LR\n    TX[\"Boot Transaction\"]\n    UTXO[\"Consumed UTxO\"]\n    TOKEN[\"New MPF Token&lt;br/&gt;asset name = SHA2-256(UTxO ref)\"]\n    STATE[\"State UTxO&lt;br/&gt;owner + empty root\"]\n\n    UTXO --&gt;|consumed| TX\n    TX --&gt;|mints| TOKEN\n    TX --&gt;|produces| STATE</code></pre>"},{"location":"architecture/validators/#migration-migrating","title":"Migration (Migrating)","text":"<p>Mints a token under the new validator by carrying over the identity and root from an old validator version.</p> <p>Validation rules:</p> <ol> <li>The old token (under <code>oldPolicy</code>) is burned (-1) in the same    transaction.</li> <li>Exactly one new token is minted.</li> <li>The token is sent to the new validator's script address.</li> <li>The output carries a <code>StateDatum</code> (root may be non-empty).</li> </ol> <pre><code>graph LR\n    OLD[\"Old State UTxO&lt;br/&gt;(old validator)\"]\n    TX[\"Migration Transaction\"]\n    NEW[\"New State UTxO&lt;br/&gt;(new validator, same root)\"]\n\n    OLD --&gt;|\"End + Burn old\"| TX\n    TX --&gt;|\"Mint new + Migrate\"| NEW</code></pre>"},{"location":"architecture/validators/#burning","title":"Burning","text":"<p>Burns the MPF token when the instance is destroyed. No additional validation beyond the spending validator's <code>End</code> redeemer.</p>"},{"location":"architecture/validators/#spending-validator-mpfcagespend","title":"Spending Validator (<code>mpfCage.spend</code>)","text":"<p>Handles five operations on UTxOs locked at the script address.</p>"},{"location":"architecture/validators/#modify-constr2","title":"Modify (ConStr2)","text":"<p>The token owner applies pending requests to the MPF trie. Only allowed during Phase 1 of each request.</p> <p>Redeemer: <code>Modify(List&lt;Proof&gt;)</code> \u2014 one proof per consumed request.</p> <p>Validation rules:</p> <ul> <li>Owner must sign the transaction.</li> <li>The transaction validity range must be entirely within Phase 1   for every consumed request (<code>tx valid before submitted_at + process_time</code>).</li> <li>Each request's <code>fee</code> must equal <code>state.max_fee</code>.</li> <li>All consumed request UTxOs reference the correct token.</li> <li>Each request is paired with a valid MPF proof.</li> <li>The proofs are folded left-to-right over the current root to   compute the new root.</li> <li>The output datum's root must equal the computed new root.</li> <li>The output datum's <code>process_time</code> and <code>retract_time</code> must equal   the input values (immutability enforced).</li> <li>The token remains at the script address.</li> <li>Each requester receives a refund of <code>lovelace - fee</code>.</li> </ul> <pre><code>graph TD\n    STATE_IN[\"State UTxO&lt;br/&gt;(current root)&lt;br/&gt;redeemer: Modify [p1, p2]\"]\n    REQ1[\"Request UTxO 1&lt;br/&gt;redeemer: Contribute(stateRef)\"]\n    REQ2[\"Request UTxO 2&lt;br/&gt;redeemer: Contribute(stateRef)\"]\n    FOLD[\"Fold proofs over root\"]\n    STATE_OUT[\"State UTxO&lt;br/&gt;(new root)\"]\n\n    STATE_IN --&gt;|Modify| FOLD\n    REQ1 --&gt;|Contribute| FOLD\n    REQ2 --&gt;|Contribute| FOLD\n    FOLD --&gt; STATE_OUT</code></pre> <p>Proof folding: For each request, the validator calls the appropriate MPF function based on the operation type:</p> Operation MPF Function Proof Shows Insert(value) <code>mpf.insert(root, key, value, proof)</code> Key is absent Delete(value) <code>mpf.delete(root, key, value, proof)</code> Key is present with value Update(old, new) <code>mpf.update(root, key, proof, old, new)</code> Key is present with old value"},{"location":"architecture/validators/#contribute-constr1","title":"Contribute (ConStr1)","text":"<p>Spends a request UTxO during an update or reject. Used together with <code>Modify</code> or <code>Reject</code> in the same transaction \u2014 the state UTxO uses <code>Modify</code>/<code>Reject</code>, while each request UTxO uses <code>Contribute</code>.</p> <p>Redeemer: <code>Contribute(OutputReference)</code> \u2014 points to the state UTxO being updated.</p> <p>Validation rules:</p> <ul> <li>The referenced state UTxO is consumed in the same transaction.</li> <li>The request's <code>requestToken</code> matches the state's token.</li> <li>The request must be in Phase 1 (for Modify) or rejectable   (Phase 3 or dishonest <code>submitted_at</code>). Phase 2 is blocked to   protect the requester's exclusive retract window.</li> </ul>"},{"location":"architecture/validators/#retract-constr3","title":"Retract (ConStr3)","text":"<p>Allows a request owner to cancel a pending request and reclaim their locked ADA. Only allowed during Phase 2.</p> <p>Redeemer: <code>Retract(OutputReference)</code> \u2014 points to the State UTxO, which must be included as a reference input (not consumed). The validator reads <code>process_time</code> and <code>retract_time</code> from the State datum to enforce phase boundaries.</p> <p>Validation rules:</p> <ul> <li>The request owner must sign the transaction.</li> <li>The State UTxO referenced by the <code>OutputReference</code> must be present   in the transaction's reference inputs.</li> <li>The request's <code>requestToken</code> must match the token in the State UTxO.</li> <li>The transaction validity range must be entirely within Phase 2   (<code>tx valid after submitted_at + process_time - 1</code> and   <code>tx valid before submitted_at + process_time + retract_time</code>).</li> </ul>"},{"location":"architecture/validators/#reject-constr4","title":"Reject (ConStr4)","text":"<p>Allows the oracle to discard expired or dishonest requests. The oracle keeps the fee and refunds the remaining lovelace to each requester. The MPF root must not change.</p> <p>Redeemer: <code>Reject</code> \u2014 applied to the state UTxO. Each request UTxO uses <code>Contribute</code>.</p> <p>Validation rules:</p> <ul> <li>Owner must sign the transaction.</li> <li>Each request must be rejectable: either in Phase 3   (<code>tx valid after submitted_at + process_time + retract_time - 1</code>)   or have a dishonest <code>submitted_at</code> (in the future).</li> <li>The output root must equal the input root (no MPF changes).</li> <li>The output datum's <code>process_time</code> and <code>retract_time</code> must equal   the input values (immutability enforced).</li> <li>The token remains at the script address.</li> <li>Each requester receives a refund of <code>lovelace - fee</code>.</li> </ul> <pre><code>graph TD\n    STATE_IN[\"State UTxO&lt;br/&gt;(root R)&lt;br/&gt;redeemer: Reject\"]\n    REQ1[\"Expired Request 1&lt;br/&gt;redeemer: Contribute(stateRef)\"]\n    REQ2[\"Expired Request 2&lt;br/&gt;redeemer: Contribute(stateRef)\"]\n    STATE_OUT[\"State UTxO&lt;br/&gt;(root R unchanged)\"]\n    REF1[\"Refund 1&lt;br/&gt;lovelace - fee\"]\n    REF2[\"Refund 2&lt;br/&gt;lovelace - fee\"]\n\n    STATE_IN --&gt; STATE_OUT\n    REQ1 --&gt; REF1\n    REQ2 --&gt; REF2</code></pre>"},{"location":"architecture/validators/#end-constr0","title":"End (ConStr0)","text":"<p>Destroys the MPF token instance.</p> <p>Validation rules:</p> <ul> <li>The token owner must sign the transaction.</li> <li>The token is burned (mint field contains -1 of the token).</li> </ul>"},{"location":"architecture/validators/#helper-functions-libak","title":"Helper Functions (<code>lib.ak</code>)","text":"Function Signature Purpose <code>quantity</code> <code>(PolicyId, Value, TokenId) -&gt; Option&lt;Int&gt;</code> Get token quantity in a value <code>assetName</code> <code>OutputReference -&gt; AssetName</code> Compute unique asset name via SHA2-256 <code>valueFromToken</code> <code>(PolicyId, TokenId) -&gt; Value</code> Construct value with exactly 1 token <code>tokenFromValue</code> <code>Value -&gt; Option&lt;TokenId&gt;</code> Extract single non-ADA token from value <code>extractTokenFromInputs</code> <code>(OutputReference, List&lt;Input&gt;) -&gt; Option&lt;(Input, TokenId)&gt;</code> Find input by ref and extract its token"}]}